<!DOCTYPE html>
<html lang="en-US">

<!-- Comparison of alife properties of directed combinators vs chemlambda
author: Marius Buliga
last modified: 14.03.2021
//
-->

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="viewport" content="width=device-width, initial-scale=1">


<link rel="stylesheet" type="text/css" href="css/icequine-on-white.css">


<title>IC vs. chemlambda life</title>
</head>


<body style="overflow: scroll;">

<script src="js/d3.v5.9.4.min.js"></script>
<script src="js/jquery.min.js"></script>
<script src="js/parameters.js"></script>
<script src="js/nodes.js"></script>
<script src="js/pagelook-vs.js"></script>
<script src="js/ioprep.js"></script>

<div class="header">
  <span3>Cite as: <br></span3><div>Alife properties of directed interaction combinators vs. chemlambda.  <a href="http://imar.ro/~mbuliga/index.html">&copy; Marius Buliga</a> (2020), https://mbuliga.github.io/quinegraphs/ic-vs-chem.html<span id="citeas"></span></div><br><br>
<span3>Version 22.05.2020, associated with <a href="https://arxiv.org/abs/2005.06060">arXiv:2005.06060</a></span3><br><br>
<span3>See also:</span3><br> <a href="https://chemlambda.github.io/index.html">All chemlambda projects</a><br><br><br><br>
<span3>
This is a framework for experimentation with two artificial chemistries: directed interaction combinators (dirIC, defined here) and <a href="https://chemlambda.github.io/index.html">chemlambda</a> [<a href="https://arxiv.org/abs/2003.14332">arXiv:2003.14332</a>]. We are interested if these chemistries allow for artificial life behaviour: replication, metabolism and death.<br><br>
The main conclusion of these experiments is that graph rewrites systems which allow conflicting rewrites are better than those which don't, as concerns their artificial life properties. This is in contradiction with the search for good graph rewrite systems for decentralized computing, where non-conflicting graph rewrite systems are historically preferred. Therefore we propose conflicting graph rewrite systems and a very simple algorithm of rewrite as a model for molecular computers.<br><br>
For the list of chemlambda rewrites and the history of versions see<br>
[<a href="https://mbuliga.github.io/quinegraphs/history-of-chemlambda.html">Graph rewrites, from emergent algebras to chemlambda. Marius Buliga (2020), https://mbuliga.github.io/quinegraphs/history-of-chemlambda.html</a>]<br><br>
Define a molecular computer as one molecule which transforms, by random chemical reactions mediated by a collection of enzymes, into a predictable other molecule, such that the output molecule can be conceived as the result of a computation encoded in the initial molecule.[<a href="https://arxiv.org/abs/1811.04960">arXiv:1811.04960</a>]<br><br>
The goal is to be able to make real life molecular computers. We use artificial chemistry to understand how to do this.<br><br>
Molecules are <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.18.5446&rep=rep1&type=pdf">port graphs in the sense of Bawden</a> with nodes decorated with a finite set of node types. 
The chemical reactions are <a href="http://eprints.adm.unipi.it/1950/1/TR-96-17.ps.gz">double push-out</a> graph rewrites mediated by enzymes: </span3><br><br><br>
(LEFT PATTERN) + (TOKEN_1) + (ENZYME) = (RIGHT PATTERN) + (TOKEN_2) + (ENZYME) <br><br><br>
<span3>where</span3> (TOKEN_1) <span3>and</span3> (TOKEN_2) <span3>are molecules which serve to make the reaction to conserve the nodes and links.<br><br> Here we do not represent these tokens, nor the enzymes in the simulations, see the <a href="https://github.com/mbuliga/hapax">hapax repository</a> for this.<br><br> 
The graph rewrites belong to a universal family, whose members appear everywhere in mathematics and physics and computer science. All of them are of the kind encountered in Interaction Nets, but they may differ by the choice of node types or port types. <br><br>
Here we compare two graph rewrites systems. The first is chemlambda. The second is Directed Interaction Combinators (dirIC), which has a double origin. In Lafont' <a href="https://pdfs.semanticscholar.org/6cfe/09aa6e5da6ce98077b7a048cb1badd78cc76.pdf">Interaction Combinators</a> is also described a directed version. We used this proposal to provide a parsing from IC to chemlambda<br><br>

<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/dirIC.jpg" alt="Parsing of IC into a chemlambda version named dirIC" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>
<div class="col-6 menu" style="text-align: center;">
</div>
</div>
We can prove that the nodes DELTA and GAMMA nodes (and the corresponding  nodes T, FRIN, FROUT and Arrow which are simply pairs of usual nodes T and Arrow) satisfy the Interaction Combinators rewrites: 

<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/DELTA-DELTA-arrow1.jpg" alt="IC: DELTA-DELTA rewrite" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>
<!--
<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/DELTA-DELTA-arrow1.jpg" alt="IC: DELTA-DELTA rewrite" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>
-->

<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/GAMMA-GAMMA-arrow1.jpg" alt="IC: GAMMA-GAMMA rewrite" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>

<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/GAMMA-DELTA.jpg" alt="IC: GAMMA-DELTA rewrite" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>

<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/term3-DELTA-T.jpg" alt="IC: DELTA-T rewrite" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>


<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/term3-GAMMA-T.jpg" alt="IC: GAMMA-T rewrite" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>


<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/remove4-T-T.jpg" alt="chemlambda v2: remove rewrites" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>

provided that we renounce at the chemlambda rewrites A-FO and A-FOE <br><br>
<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/A-FO.jpg" alt="chemlambda rewrite A-FO" style="width:350px;border:0">
</div>
<div class="col-6 menu" style="text-align: center;">
<img src="img/A-FOE.jpg" alt="chemlambda rewrite A-FOE" style="width:350px;border:0"> 
<br><br>
</div>
</div>
and we replace them by a rewrite FI-A.<br><br>
<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/FI-A.jpg" alt="chemlambda rewrite FI-A" style="width:350px;border:0"> <br><br>
</div>
<div class="col-6 menu" style="text-align: center;">
</div>
</div>
Some termination rewrites are modified as well. More precisely, these termination rewrites from chemlambda v2 are eliminated:

<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/termL-L-T.jpg" alt="chemlambda v2: L-T rewrite" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>

<div class="col-6 menu" style="text-align: center;">
<img src="img/term1-FOE-T.jpg" alt="chemlambda v2: FOE-T rewrite" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>
</div>

<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/term1-FO-T.jpg" alt="chemlambda v2: FO-T rewrite" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>

<div class="col-6 menu" style="text-align: center;">
<img src="img/term-A-T.jpg" alt="chemlambda v2: A-T rewrite" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>
</div>

and replaced by these different termination rewrites:

<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/termLD-L-T.jpg" alt="dirIC: L-T rewrite" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>

<div class="col-6 menu" style="text-align: center;">
<img src="img/term3-A-T.jpg" alt="dirIC: A-T rewrite" style="padding: 20px; margin-bottom: 18px; width:350px;border:0"><br><br>
</div>
</div>


The chemistries are described in the file <a href="https://github.com/mbuliga/quinegraphs/blob/master/js/chemistry.js">chemistry.js</a>. Chemlambda rewrites are obtained by concatenation of "CHEMLAMBDABARE" with "CHEMLAMBDAEND" and dirIC rewrites are obtained from concatenation of "CHEMLAMBDABARE" with "DICMOD". General pure termination rewrites "T" and the "COMB" rewrites which manage the Arrow nodes are part of both chemistries.


The resulting graph rewrite system is very close to Asperti' <a href="https://github.com/asperti/BOHM1.1">BOHM machine</a> graph rewrite system. <br><br>
For the purposes of this work, the main difference between these two graph rewrite systems is that chemlambda has conflicting rewrite (patterns) and dirIC does not have such patterns. The cause of this difference is that some chemlambda nodes have two active ports while all dirIC nodes (as well as the original IC nodes) have only one active port. <br><br><br> 
</span3>1st hypothesis:<span> these rewrites can also be used to make real molecular computers.</span><span3><br><br>
</span3>2nd hypothesis:<span> the enzymes create a graph rewriting algorithm which can be implemented by local machines.</span><span3> <br><br>
Here a local machine is a defined as a Turing machine with two tapes: the IO tape and the work tape. Molecules are encoded as mol patterns, which are vectors of mol nodes, where each mol node is a vector of node types and tags of edges connected to the node ports. The tapes of the machine have cells, each cell of a tape can contain a node type, a port type, an edge tag or a finite set of special characters. <br><br>
The machine can read from on the IO tape a cell, write a whole mol node at the end of the mol pattern, or delete a whole mol node.  
For each read/write or delete from/to the IO tape the machine writes the same on the work tape.  
The machine can read from the work tape and it can write only on the blank cells of the work tape. 
The machine can either halt (by writing a halt symbol on the work tape) or it can delete the whole work tape and then the IO head jumps to a random mol node beginning. <br><br> 
The constraints are: <br><br> 
- the machine can perform any graph rewrite on any molecule <br>
- at each moment the IO tape contains only a well written mol pattern <br>
- the work tape has finite length.<br><br>
A graph rewriting algorithm which can be implemented by a local machine is by definition local in space, in the sense that the graph rewrites can be performed by using a local machine (therefore by a TM with a finite work tape), and local in time, in the sense that the algorithm can retain only a limited in time portion of the history of the graph evolution. <br><br>
In these simulations we use a random rewrite algorithm and we also randomize as many times as necessary the data (mol file, list of possible rewrites,...) in order to destroy all information which cannot be processed by a local machine. As an example, the list of nodes in the mol file is ordered, but we have to avoid this information and instead to jump randomly to a node or explore from a node only a limited portion of the graph. The only exception we make is to be able to use an age of the node or of the link of the graphs, for the purpose of searching for quine graphs (see below about the use of the "change" button for the "older is first" option). We could, instead use a local algorithm based on age, where there is a upper age parameter such that the age of a node or link which is bigger than the upper age trigger an age reset (and also it may trigger a rewrite, like deletion of the old node or link). However, in these experiments we don't go in this direction.<br><br>
  
</span3>Problem:<span> find those graph rewrite systems which admit artificial life, i.e. graphs (molecules) with the properties <br><br>
- they have metabolism (graph quines)<br>
- they can duplicate<br>
- they can die.</span><span3><br><br>
Here a graph quine is a molecule which admits a periodic evolution under graph rewrites, provided the local machine is constrained to rewrite older graph rewrites patterns first and to choose one among the possible strategies:  whenever possible to prefer the rewrites which grow the number of nodes ("GROW") vs those which reduce the number of nodes ("SLIM") or inversely. <br><br>
Once we have a graph quine, we are interested if such a molecule can duplicate or die if the local machine is not constrained by the age of the rewrites patterns or by the choice of a strategy. <br><br>
</span3>Comment:<span> this definition of metabolism is very low level. Indeed, according to it, the citric acid cycle defines a graph quine. [<a href="https://en.wikipedia.org/wiki/Citric_acid_cycle#/media/File:Citric_acid_cycle_with_aconitate_2.svg">image source: wikipedia</a>]
</span><span3><br><br>
<div class="row">
<div class="col-6 menu" style="text-align: center;">
<img src="img/1024px-Citric_acid_cycle_with_aconitate_2.svg.png" alt="citric acid cycle" style="width:700px;border:0"> <br><br>
</div>
</div>


Death of a quine graph is understood as the evolution to a state where no more graph rewrites are possible.<br><br>
We see in these experiments that the choice of the graph rewrite system is important if we want to have graphs with these artificial life properties. <br><br>
We can experiment with 10 chemlambda quines and with 5 Interaction Combinators quines, on the same ground. There are comments relevant for each quine, which appear when the user chooses a quine from the menu. We use a list of quines which contain those initially presented in <br>[<a href="https://mbuliga.github.io/quinegraphs/ice.html#howto">IC &amp; chemlambda quines. Marius Buliga (2019-2020), https://mbuliga.github.io/quinegraphs/ice.html#howto</a>].<br>
For a graphically more lively, with more examples, but with less explanations page, see the older<br>
[<a href="https://mbuliga.github.io/find-the-quine.html">Find a quine. Marius Buliga (2019), https://mbuliga.github.io/find-the-quine.html</a>]<br><br>
There are examples which show that:<br><br>
- a chemlambda quine may be as big as we wish (the "ouroboros quine"). This is the first discovered chemlambda quine, from the graphical reduction of the predecessor of a Church number, as explained in <br>[<a href="https://mbuliga.github.io/quinegraphs/ouroboros.html#howto">The Ouroboros. Marius Buliga (2019-2020), https://mbuliga.github.io/quinegraphs/ouroboros.html#howto</a>]<br>
- some chemlambda quines can duplicate (the 10_nodes quine),<br>
- there exist non-connected quines (the 16_quine_A_L_FI-FO) which are not made by connected components which are quines,<br>
- birth of quines (16_quine_A_L_FI_FO_duplicate), see also this first string of demos<br>
  [<a href="http://chorasimilarity.github.io/chemlambda-gui/dynamic/A_L_eggshell.html">The birth and metabolism of a chemlambda quine. Marius Buliga (chorasimilarity) 2015,http://chorasimilarity.github.io/chemlambda-gui/dynamic/A_L_eggshell.html</a><br> 
- there exist chemlambda graphs which can evolve into two different quine graphs (nature vs. nurture),<br>
- quines can be combined into bigger quines, by "hybridization", see here hybrids and the first explanation in the commented animation<br>
[<a href="https://chemlambda.github.io/collection.html#4">How big an artificial living molecule can be? Chemlambda collection of animations. Marius Buliga (2017-2020), https://chemlambda.github.io/collection.html#4</a>]<br><br>
IC quines are given as well, starting with Lafont' quine, which appears in the foundational article about interaction combinators, and continuing with IC quines discovered from random search in a big family of IC graphs.<br><br>
There are also options to search for new quines among random graphs. <br><br>
For the IC quines we can transform them into dirIC graphs, which have nodes compatible with chemlambda. For any of these quines we can see their evolution under chemlambda or under dirIC. <br><br>
In order to verify if a graph is a quine we need to do the following, as described in <br>[<a href="https://mbuliga.github.io/quinegraphs/quinecheck.html">How to test a quine. Marius Buliga (2019-2020), https://mbuliga.github.io/quinegraphs/quinegraph.html#howtoquine</a>]: <br><br>
- click on the first "change" button on the left to see the message "older is first".<br>
- choose among the two extremal strategies "GROW" or "SLIM" by moving the rewrites weights slider. For chemlambda or IC quines the choice is "GROW".<br>
- choose among the chemistries dirIC or chemlambda by using the second "change" buton. <br><br>
If the evolution of the graph is periodic then we have a quine. <br><br>
These quines have a metabolism, in the following sense. We use the first "change" button in order to have "random choices" and we move the rewrites weights slider to the middle (or we can position it as we like in different experiments, or even during the evolution of the graph). We are now in the random rewrites algorithm. A graph (in particular a quine graph) exhibits metabolism if it has an approximately periodic evolution for an ammount of time, followed perhaps by death. Death is lack of rewrites available. <br><br>
Use the third "change" button to move from "colored nodes" to "uncolored nodes", to see how the new nodes replace the old nodes of the graph. If we are set on "uncolored nodes" then all the new nodes will have the same color. When you click again on the third "change" button, you see the text "colored nodes" and the effect is that the new nodes will have the standard (different according to their type) colors.<br><br>
We see that chemlambda quines as well as  dirIC quines exhibit metabolism, but only chemlambda quines may die. The lack of conflicting rewrite patterns induces a unique final state of  a graph, when it exists, which is a desired property in distributed computing. The same unicity is not desired in artificial life.<br><br>
We achieved replication in chemlambda but not in dirIC, probably due to a lack of enough experiments. <br><br>
A curious phenomenon is that some IC quines do not translate to dirIC quines. This is due to the fact that the translation from IC to dirIC works as expected for graph which have a final state where there is no possible reduction left. In the case of an IC quine, the reduction does not terminate, it is periodic. When translated to a dirIC graph we know that the reduction can't terminate, but there is no guarantee that the reduction is periodic. We only know that if we synchronize the rewrites (so as to respect the fact that a rewrite in IC is two rewrites in dirIC) then we shall have a periodic evolution.<br><br>
Some chemlambda quines are dirIC quines as well and inversely. But more times (as shown by experiments) a chemlambda quine dies fast in the process of quine checking (i.e. "GROW" strategy and "older is first"). Namely this happens for chemlambda quines which can die (attain a final state) under the rewrites from CHEMLAMBDABARE.<br><br>
Finally, if we want to explore the computational properties of these chemistries, see <br>[<a href="https://mbuliga.github.io/quinegraphs/lambda2mol.html">Lambda calculus to chemlambda. Marius Buliga (2019-2020), https://mbuliga.github.io/quinegraphs/lambda2mol.html#lambdanote</a>],<br> which is a parser and reducer which has the option to choose the chemistry for reduction of lambda calculus terms. Under this simple rewriting algorithm, chemlambda is better than dirIC, but nevertheless the dirIC has many cases where it reduces lambda terms as well.<br><br>


</span3>

</div>

<div class="row">
  <div class="col-1 menu" style="text-align: left;">
  </div>
  <div class="col-7 menu">
    <ul>
      <li>    
        <span2> 
          <select  class="theme-construction" id="listofmols" onchange="selectionICLambda();">
            <option value="icvschem">MENU</option>
            <option value="omega">&lambda; quine: omega combinator </option>
            <option value="bigpred_train"> first chemlambda quine: the ouroboros </option>
            <option value="Lafont-quine"> Lafont' quine </option>
            <option value="4_IC_6B784A053912"> IC quine: "4_IC_6B784A053912" </option>
            <option value="4_IC_84B7362190A5"> IC quine: "4_IC_84B7362190A5" </option>
            <option value="4_IC_60852B93A714"> IC quine: "4_IC_60852B93A714" </option>
            <option value="4_IC_5AB718246309"> IC quine:  "4_IC_5AB718246309" </option>
            <option value="random_egg_G_G_D_D"> random 2 GAMMA + 2 DELTA nodes IC graph </option>
            <option value="spark_243501">chemlambda quine: "spark_243501"</option>
            <option value="9_quine">chemlambda quine: "9_quine"</option>
            <option value="10_quine_bubbles">chemlambda quine: "10_quine_bubbles"</option>
            <option value="16_quine_A_L_FI_FO">chemlambda quine: "16_quine_A_L_FI_FO"</option>
            <option value="16_quine_A_L_FI_FO_duplicate">"16_quine_A_L_FI_FO_duplicate"</option>
            <option value="alexo_example">"alexo_example"</option>
            <option value="shuffle_10_290C1735B6A4DE8">10 nodes sometimes becomes quine from [graph A-L-FI-FOE 540213]</option>
            <option value="square_quine">hybrid of two "sparkFOE_540213" gives "square_quine"</option>
            <option value="shuffle_10_3D25C769B1E804A">"shuffle_10_3D25C769B1E804A"</option>
            <option value="shuffle_10_0A8E7D9132C546B">"shuffle_10_0A8E7D9132C546B"</option>
            <option value="shuffle_10_51D3E60BA74C928">"shuffle_10_51D3E60BA74C928"</option>
            <option value="shuffle_10_D870619BC345AE2">"shuffle_10_D870619BC345AE2"</option>
            <option value="random_10_quine_bubbles">"random_10_quine_bubbles"</option>
          </select>
        </span2> 
      </li>
<!--
      <li> &lambda;>mol &nbsp;<div><textarea id="inputlambda" class="image2" style="height: 80px; width: 100%;  background-color: #010101; 
 color: #6495ED;  font-size: 14px;">(\n.(\f.(\x.(((n (\g.(\h.(h (g f))))) (\u.x)) (\u.u))))) (((\b.(\e.(e b))) (\f.(\x.(f (f (f x)))))) (\f.(\x.(f(f (f (f x)))))))</textarea> </div>
      </li>
      <li> mol>&lambda; &nbsp;<div><textarea id="evaluation" class="image2" style="height: 80px; width: 100%;  background-color: #010101; 
 color: #6495ED;  font-size: 14px;"></textarea> </div></li>
-->
      <li>
         <span3>rewrites weights slider</span3> <div class="slidecontainer">GROW &nbsp;<input class="slider" type="range" min="0" max="100" value="50" id="rewritesRange"> &nbsp; SLIM</div>
      </li>
    </ul>
      <div class="slidecontainer">
        <div class="sscol-4">
          <span3 id="agetext">random choices </span3><br><br>
          <span3  id="buttonAge" class="image2" ></span3></div>
        <div class="sscol-4">
          <span3 id="chemtext">chem&lambda;</span3><br><br>
          <span3  id="whichChem" class="image2" ></span3></div>
        <div class="sscol-4">
          <span3 id="metabotext">colored nodes</span3><br><br>
          <span3  id="whichMetabo" class="image2" ></span3>
        </div>
        </div>
  </div>
  <div class="col-4 menu" style="text-align: left;">
    <span3 style="text-align: left;"> nodes &sim; </span3><span id="nodenumber"></span><br><br>
    <span3 id="errors"></span3>
  </div>
</div>

<div class="row">
  <div class="col-2 menu">
    <!-- <div class="scol-12"> <span3  id="lambdatomolbutton" class="image2" ></span3></div> -->
  </div>
  <div class="col-6 menu">
<!--<div><textarea id="inputlambda" style="height: 50px; width: 100%;"></textarea> </div> -->
  </div>
  <div class="col-4 menu" style="text-align: left;">
  </div>
</div>

<div class="row">
  <div class="col-2 menu">
    <div class="scol-12"> <span3  id="button0" class="image2" ></span3></div>
    <div class="scol-12"> <span3  id="button1" class="image2" ></span3></div>
    <div class="scol-12"> <span3  id="button2" class="image2" ></span3></div>
    <div class="scol-12"> <span3  id="button3" class="image2" ></span3></div>
    <div class="scol-12"> <span3  id="button4" class="image2" ></span3></div>
  </div>
  <div class="col-6 menu">
    <ul>
      <li> <div id="svgdiv"> </div></li>
      <li><span3>gravity slider</span3> <div class="slidecontainer">MIN &nbsp;<input class="slider" type="range" min="1" max="250" value="150" id="gravRange"> &nbsp; MAX</div></li>
      <li><span2>CODE: </span2><span id="molyoulookat"></span></li>
      <li><span> (Rewrites stop at max.  </span><span id="maxnodenumber">1024</span> nodes<span>)</span></li>
    </ul>
  </div>
  <div class="col-4 menu" style="text-align: left;">
    <span id="comments" ></span>
  </div>
</div>

<div class="row">
      <div class="scol-6" style="text-align: left;">
        <span2>before:</span2><br><br>
        <span id="puttransformcachealt"></span>
      </div> 
      <div class="scol-6" style="text-align: left;">
        <span2>chosen:</span2><br><br>
        <span id="chosentransform"></span>
      </div>
      <div class="scol-6" style="text-align: left;">
        <span2>after:</span2><br><br>
        <span id="puttransformcachealtafter"></span>
      </div>
    <div class="scol-6" style="text-align: left;">
      <span2>mol before:</span2><br><br>
      <span id="molexport"></span>
    </div>
    <div class="scol-6" style="text-align: left;">
      <span2>mol after:</span2><br><br>
      <span id="molexportafter"></span>
    </div>
</div>


<script src="js/iceMol.js"></script>
<script src="js/iceComments.js"></script>
<script src="js/chemistry.js"></script>
<!-- <script src="js/reactions.js"></script> -->
<script src="js/myD3Graph.js"></script>
<script src="js/icequine.js"></script>
<script src="js/0parser.js"></script>
<script src="js/lambdaTerms.js"></script>


<script>
var whichP = location.hash;
whichP = whichP.replace(/#/g, "");
if (whichP != "") {
document.getElementById("listofmols").value = whichP;
} else {
document.getElementById("listofmols").value = "icvschem";
}
whichButtons("icvschem"); 
selectionICLambda();
setBalanceOfNodes();
</script>

</body>
</html>


